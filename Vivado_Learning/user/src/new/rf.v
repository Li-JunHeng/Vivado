`timescale 1ns / 1ps

// =============================================================
// RF: 寄存器堆 (Register File) - RV32I 32 个通用寄存器 x0~x31
// =============================================================
// 功能: 实现 RISC-V RV32I 架构的 32 个 32 位通用寄存器
//
// 接口说明:
//   - A1/A2  : 读地址 (对应 rs1/rs2)
//   - RD1/RD2: 读数据 (组合读: 地址变化会立刻反映到输出)
//   - A3     : 写地址 (对应 rd)
//   - WD     : 写数据
//   - RFWr   : 写使能 (为 1 时在时钟上升沿写入)
//
// RISC-V 约定: x0 永远为 0
//   - 读 x0 时直接输出 0
//   - 写 x0 时必须忽略 (这里用 A3 != 0 做保护)
// =============================================================

// =============================================================
// RV32I 寄存器 ABI 名称对照表
// =============================================================
// 编号   | ABI名  | 用途                      | 调用约定
// -------|--------|---------------------------|------------------
//  x0    | zero   | 硬连线常数 0              | -
//  x1    | ra     | 返回地址 (Return Address) | 调用者保存
//  x2    | sp     | 栈指针 (Stack Pointer)    | 被调用者保存
//  x3    | gp     | 全局指针 (Global Pointer) | -
//  x4    | tp     | 线程指针 (Thread Pointer) | -
//  x5    | t0     | 临时寄存器 0              | 调用者保存
//  x6    | t1     | 临时寄存器 1              | 调用者保存
//  x7    | t2     | 临时寄存器 2              | 调用者保存
//  x8    | s0/fp  | 保存寄存器/帧指针         | 被调用者保存
//  x9    | s1     | 保存寄存器 1              | 被调用者保存
//  x10   | a0     | 函数参数/返回值 0         | 调用者保存
//  x11   | a1     | 函数参数/返回值 1         | 调用者保存
//  x12   | a2     | 函数参数 2                | 调用者保存
//  x13   | a3     | 函数参数 3                | 调用者保存
//  x14   | a4     | 函数参数 4                | 调用者保存
//  x15   | a5     | 函数参数 5                | 调用者保存
//  x16   | a6     | 函数参数 6                | 调用者保存
//  x17   | a7     | 函数参数 7                | 调用者保存
//  x18   | s2     | 保存寄存器 2              | 被调用者保存
//  x19   | s3     | 保存寄存器 3              | 被调用者保存
//  x20   | s4     | 保存寄存器 4              | 被调用者保存
//  x21   | s5     | 保存寄存器 5              | 被调用者保存
//  x22   | s6     | 保存寄存器 6              | 被调用者保存
//  x23   | s7     | 保存寄存器 7              | 被调用者保存
//  x24   | s8     | 保存寄存器 8              | 被调用者保存
//  x25   | s9     | 保存寄存器 9              | 被调用者保存
//  x26   | s10    | 保存寄存器 10             | 被调用者保存
//  x27   | s11    | 保存寄存器 11             | 被调用者保存
//  x28   | t3     | 临时寄存器 3              | 调用者保存
//  x29   | t4     | 临时寄存器 4              | 调用者保存
//  x30   | t5     | 临时寄存器 5              | 调用者保存
//  x31   | t6     | 临时寄存器 6              | 调用者保存
// =============================================================
//
// 调用约定说明:
// - 调用者保存: 调用函数前，调用者需要保存这些寄存器的值
// - 被调用者保存: 被调用函数需要保证返回时这些寄存器的值不变
// =============================================================
//
// 初学者提示:
// - "组合读 + 同步写" 是寄存器堆最常见的实现方式
// - always @(posedge clk ...) 里用非阻塞赋值 <=，表示寄存器在时钟沿更新
// - for 循环的初始化通常用于仿真/复位
// =============================================================

module RF (
    input         clk,      // 时钟
    input         rstn,     // 复位信号 (低电平有效)
    input         RFWr,     // 写使能
    input  [15:0] sw_i,     // 开关输入 (sw_i[1] 用于调试模式)
    input  [4:0]  A1,       // 读地址 1 (rs1)
    input  [4:0]  A2,       // 读地址 2 (rs2)
    input  [4:0]  A3,       // 写地址 (rd)
    input  [31:0] WD,       // 写数据
    output [31:0] RD1,      // 读数据 1
    output [31:0] RD2       // 读数据 2
);

    // ---------------------------------------------------------
    // 1. 寄存器堆存储
    // ---------------------------------------------------------
    reg [31:0] reg_file [0:31];  // 32 个 32 位寄存器
    integer idx;

    // ---------------------------------------------------------
    // 2. 读操作 (组合逻辑 - 异步读)
    // ---------------------------------------------------------
    // x0 硬连线为 0，读 x0 时直接返回 0
    // 其他寄存器正常返回存储的值
    assign RD1 = (A1 == 5'd0) ? 32'd0 : reg_file[A1];
    assign RD2 = (A2 == 5'd0) ? 32'd0 : reg_file[A2];

    // ---------------------------------------------------------
    // 3. 写操作 (时序逻辑 - 同步写)
    // ---------------------------------------------------------
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            // ---------------------------------------------------
            // 复位初始化 (用于仿真/测试)
            // ---------------------------------------------------
            // 初始化说明:
            // - x1 (ra) = 84   : 预设返回地址
            // - x2 (sp) = 250  : 栈指针指向内存高端 (DM 大小 256)
            // - x10 (a0) = 10  : 函数参数，用于 Fibonacci(10) 测试
            // - 其他 xi = i    : 便于调试观察
            // ---------------------------------------------------
            for (idx = 0; idx < 32; idx = idx + 1) begin
                if (idx == 1)
                    reg_file[idx] <= 32'd84;   // x1 (ra): 返回地址
                else if (idx == 2)
                    reg_file[idx] <= 32'd250;  // x2 (sp): 栈指针
                else if (idx == 10)
                    reg_file[idx] <= 32'd10;   // x10 (a0): 参数
                else
                    reg_file[idx] <= idx;      // 其他: 初始化为自身索引
            end
        end
        else begin
            // ---------------------------------------------------
            // 正常写入条件:
            // 1. RFWr = 1 (写使能有效)
            // 2. A3 != 0 (不能写 x0)
            // 3. sw_i[1] = 0 (非调试模式)
            // ---------------------------------------------------
            // 调试模式 (sw_i[1]=1) 下禁止写入，便于在 FPGA 上
            // "暂停 CPU" 观察寄存器内容
            // ---------------------------------------------------
            if (RFWr && (A3 != 5'd0) && (sw_i[1] == 1'b0)) begin
                reg_file[A3] <= WD;
            end
        end
    end

endmodule
