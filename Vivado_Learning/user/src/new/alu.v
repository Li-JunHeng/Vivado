`timescale 1ns / 1ps

// =============================================================
// ALU: 算术逻辑单元 (Arithmetic Logic Unit)
// =============================================================
// 功能: 根据 ALUOp 对两个 32 位操作数 A/B 做运算，输出结果 C
//
// 输入:
//   - A      : 第一个操作数 (通常来自 rs1 或 PC)
//   - B      : 第二个操作数 (通常来自 rs2 或立即数)
//   - ALUOp  : 操作类型选择
//
// 输出:
//   - C      : 运算结果
//   - Zero   : 零标志 (C == 0 时为 1)，用于分支判断 (BEQ/BNE)
// =============================================================

// =============================================================
// ALUOp 编码定义 (与 ctrl.v 保持同步)
// =============================================================
// ALUOp | 操作   | 描述                        | 适用指令
// ------|--------|-----------------------------|-----------------------
//   0   | ADD    | 加法: C = A + B             | ADD/ADDI/Load/Store/AUIPC/JAL/JALR
//   1   | SUB    | 减法: C = A - B             | SUB/BEQ/BNE
//   2   | SLL    | 逻辑左移: C = A << B[4:0]   | SLL/SLLI
//   3   | SLT    | 有符号比较: C = (A < B)     | SLT/SLTI/BLT/BGE
//   4   | SLTU   | 无符号比较: C = (A < B)     | SLTU/SLTIU/BLTU/BGEU
//   5   | XOR    | 按位异或: C = A ^ B         | XOR/XORI
//   6   | SRL    | 逻辑右移: C = A >> B[4:0]   | SRL/SRLI
//   7   | SRA    | 算术右移: C = A >>> B[4:0]  | SRA/SRAI
//   8   | OR     | 按位或: C = A | B           | OR/ORI
//   9   | AND    | 按位与: C = A & B           | AND/ANDI
//  10   | LUI    | 直通 B: C = B               | LUI
//  11   | DIY    | 自定义计算 (如 MIN/MAX)     | DIY_CALC
//  12   | DIY_BR | 自定义分支辅助              | DIY_BRANCH
// =============================================================
//
// 初学者提示:
// - 本模块是"组合逻辑": 使用 always @(*)，输入变了输出就立即更新
// - 组合逻辑里通常用阻塞赋值"="，写起来更像"按步骤算结果"
// - A/B 声明为 signed，便于实现 SLT/SRA 等带符号运算
// - 移位量只看低 5 位 (B[4:0])，因为 32 位数据移位最多 0~31 位
// =============================================================

module alu(
    input  signed [31:0] A,      // 操作数 A (有符号)
    input  signed [31:0] B,      // 操作数 B (有符号)
    input         [4:0]  ALUOp,  // ALU 操作类型
    output reg    [31:0] C,      // 运算结果
    output               Zero   // 零标志
);

    // ---------------------------------------------------------
    // 1. ALUOp 常量定义
    // ---------------------------------------------------------
    localparam ALU_ADD     = 5'd0;   // 加法
    localparam ALU_SUB     = 5'd1;   // 减法
    localparam ALU_SLL     = 5'd2;   // 逻辑左移
    localparam ALU_SLT     = 5'd3;   // 有符号比较
    localparam ALU_SLTU    = 5'd4;   // 无符号比较
    localparam ALU_XOR     = 5'd5;   // 按位异或
    localparam ALU_SRL     = 5'd6;   // 逻辑右移
    localparam ALU_SRA     = 5'd7;   // 算术右移
    localparam ALU_OR      = 5'd8;   // 按位或
    localparam ALU_AND     = 5'd9;   // 按位与
    localparam ALU_LUI     = 5'd10;  // 直通 B (LUI)
    localparam ALU_DIY_CALC= 5'd11;  // DIY 计算
    localparam ALU_DIY_BR  = 5'd12;  // DIY 分支辅助

    // ---------------------------------------------------------
    // 2. ALU 运算逻辑 (组合逻辑)
    // ---------------------------------------------------------
    always @(*) begin
        case(ALUOp)
            // -------------------------------------------------
            // ADD: 加法
            // -------------------------------------------------
            // 用于: ADD, ADDI, Load地址计算, Store地址计算,
            //       AUIPC (PC + imm), JAL/JALR 地址计算
            ALU_ADD:
                C = A + B;

            // -------------------------------------------------
            // SUB: 减法
            // -------------------------------------------------
            // 用于: SUB 指令
            // 分支时: BEQ/BNE 通过 A-B 判断相等
            //        若 A == B，则 A-B == 0，Zero = 1
            ALU_SUB:
                C = A - B;

            // -------------------------------------------------
            // SLL: 逻辑左移 (Shift Left Logical)
            // -------------------------------------------------
            // 将 A 的所有位向左移动 B[4:0] 位
            // 右侧空出的位补 0
            // 例: 0x00000001 << 4 = 0x00000010
            ALU_SLL:
                C = A << B[4:0];

            // -------------------------------------------------
            // SLT: 有符号小于比较 (Set Less Than)
            // -------------------------------------------------
            // 若 A < B (有符号比较)，则 C = 1，否则 C = 0
            // 用于: SLT, SLTI 指令
            // 分支时: BLT/BGE 通过 C[0] 判断大小关系
            ALU_SLT:
                C = (A < B) ? 32'd1 : 32'd0;

            // -------------------------------------------------
            // SLTU: 无符号小于比较 (Set Less Than Unsigned)
            // -------------------------------------------------
            // 若 A < B (无符号比较)，则 C = 1，否则 C = 0
            // 用于: SLTU, SLTIU 指令
            // 分支时: BLTU/BGEU 通过 C[0] 判断大小关系
            ALU_SLTU:
                C = ($unsigned(A) < $unsigned(B)) ? 32'd1 : 32'd0;

            // -------------------------------------------------
            // XOR: 按位异或
            // -------------------------------------------------
            // 对应位不同则为 1，相同则为 0
            // 例: 0xF0F0 ^ 0xFF00 = 0x0FF0
            ALU_XOR:
                C = A ^ B;

            // -------------------------------------------------
            // SRL: 逻辑右移 (Shift Right Logical)
            // -------------------------------------------------
            // 将 A 的所有位向右移动 B[4:0] 位
            // 左侧空出的位补 0 (不考虑符号)
            // 例: 0x80000000 >> 4 = 0x08000000
            ALU_SRL:
                C = A >> B[4:0];

            // -------------------------------------------------
            // SRA: 算术右移 (Shift Right Arithmetic)
            // -------------------------------------------------
            // 将 A 的所有位向右移动 B[4:0] 位
            // 左侧空出的位用符号位 (A[31]) 填充
            // 例: 0x80000000 >>> 4 = 0xF8000000 (负数保持负)
            // 注意: Verilog 中需要 A 声明为 signed 才能正确使用 >>>
            ALU_SRA:
                C = A >>> B[4:0];

            // -------------------------------------------------
            // OR: 按位或
            // -------------------------------------------------
            // 任一对应位为 1 则结果为 1
            // 例: 0xF0F0 | 0x0F0F = 0xFFFF
            ALU_OR:
                C = A | B;

            // -------------------------------------------------
            // AND: 按位与
            // -------------------------------------------------
            // 两个对应位都为 1 才为 1
            // 例: 0xF0F0 & 0xFF00 = 0xF000
            ALU_AND:
                C = A & B;

            // -------------------------------------------------
            // LUI: Load Upper Immediate
            // -------------------------------------------------
            // 直接输出 B (扩展后的立即数)
            // EXT 模块已将 imm[31:12] 放到高位，低 12 位为 0
            ALU_LUI:
                C = B;

            // =================================================
            // 【DIY 预留区 1】自定义"计算类"运算 (ALUOp=11)
            // =================================================
            ALU_DIY_CALC: begin
                // 你可以在这里实现自定义运算，例如:
                // - MIN: 返回 A、B 中较小的那个
                // - MAX: 返回 A、B 中较大的那个
                // - ABS: 返回 A 的绝对值
                // - CLZ: 计算前导零个数
                //
                // 【示例: MIN 函数】返回较小值 (有符号比较)
                C = ($signed(A) < $signed(B)) ? A : B;

                // 【示例: MAX 函数】返回较大值
                // C = ($signed(A) > $signed(B)) ? A : B;

                // 【示例: ABS 函数】返回 A 的绝对值
                // C = (A[31]) ? (~A + 1) : A;
            end

            // =================================================
            // 【DIY 预留区 2】自定义"分支辅助"逻辑 (ALUOp=12)
            // =================================================
            ALU_DIY_BR: begin
                // 分支类指令往往需要"比较结果"
                // 为了节省硬件，常复用 ALU 来输出比较用的 0/1
                //
                // 【示例 1: BGT 辅助】为"大于跳转"准备
                // 输出 A < B 的标志 (1 表示 A < B)
                // 在 npc.v 中判断: branch_taken = (~C[0]) && (~Zero)
                C = (A < B) ? 32'd1 : 32'd0;

                // 【示例 2: BODD 辅助】为"奇数跳转"准备
                // 输出 A & 1，若 A 为奇数则结果为 1
                // 在 npc.v 中判断: branch_taken = ~Zero
                // C = A & 32'h1;

                // 【示例 3: BLE 辅助】为"小于等于跳转"准备
                // 可以复用 SLT 逻辑，在 npc.v 中结合 Zero 判断
                // C = (A < B) ? 32'd1 : 32'd0;
            end

            default:
                C = 32'd0;
        endcase
    end

    // ---------------------------------------------------------
    // 3. Zero 标志输出
    // ---------------------------------------------------------
    // 当运算结果 C 等于 0 时，Zero = 1
    // 主要用于:
    // - BEQ: 若 A == B，则 A-B == 0，Zero = 1，跳转
    // - BNE: 若 A != B，则 A-B != 0，Zero = 0，跳转
    assign Zero = (C == 32'd0);

endmodule
